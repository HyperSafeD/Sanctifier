{
  "version": "1.0.0",
  "last_updated": "2026-02-26",
  "description": "Community-sourced vulnerability database for Soroban smart contracts",
  "vulnerabilities": [
    {
      "id": "SOL-2024-001",
      "name": "Unprotected Initialization",
      "description": "Contract initialize/init function lacks access control, allowing anyone to re-initialize and take ownership.",
      "severity": "critical",
      "category": "access-control",
      "pattern": "fn\\s+(initialize|init)\\s*\\([^)]*\\)(?![\\s\\S]*?require_auth)",
      "recommendation": "Add require_auth() check or verify the contract has not been initialized before.",
      "references": ["https://soroban.stellar.org/docs/fundamentals/authorization"]
    },
    {
      "id": "SOL-2024-002",
      "name": "Missing Auth on Token Transfer",
      "description": "Token transfer function modifies balances without verifying the caller's authorization.",
      "severity": "critical",
      "category": "access-control",
      "pattern": "fn\\s+transfer\\s*\\([^)]*\\)[^}]*storage\\(\\)[^}]*set\\(",
      "recommendation": "Call env.require_auth(&from) before modifying balances in transfer functions.",
      "references": ["https://soroban.stellar.org/docs/fundamentals/authorization"]
    },
    {
      "id": "SOL-2024-003",
      "name": "Unchecked Balance Underflow",
      "description": "Balance subtraction without verifying sufficient funds, leading to potential underflow.",
      "severity": "high",
      "category": "arithmetic",
      "pattern": "balance\\s*-\\s*amount|balance\\.checked_sub\\s*\\(\\s*amount\\s*\\)\\.unwrap\\(\\)",
      "recommendation": "Use checked_sub() and handle the error case explicitly instead of allowing underflow or panicking.",
      "references": []
    },
    {
      "id": "SOL-2024-004",
      "name": "Missing TTL Extension",
      "description": "Persistent storage entries without TTL extension calls may expire unexpectedly, causing data loss.",
      "severity": "medium",
      "category": "storage",
      "pattern": "storage\\(\\)\\.persistent\\(\\)\\.set\\([^)]*\\)(?![\\s\\S]{0,200}extend_ttl)",
      "recommendation": "Call extend_ttl() after writing to persistent storage to prevent unexpected expiration.",
      "references": ["https://soroban.stellar.org/docs/fundamentals/state-archival"]
    },
    {
      "id": "SOL-2024-005",
      "name": "Hardcoded Admin Key",
      "description": "Admin or privileged addresses hardcoded directly in contract source code.",
      "severity": "high",
      "category": "access-control",
      "pattern": "Address::from_string|ADMIN.*=.*\"G[A-Z2-7]{55}\"",
      "recommendation": "Store admin addresses in contract storage and set them during initialization.",
      "references": []
    },
    {
      "id": "SOL-2024-006",
      "name": "Unprotected Mint Function",
      "description": "Token mint function without access control allows anyone to create tokens.",
      "severity": "critical",
      "category": "access-control",
      "pattern": "fn\\s+mint\\s*\\([^)]*\\)(?![\\s\\S]*?require_auth)",
      "recommendation": "Restrict minting to authorized addresses using require_auth().",
      "references": []
    },
    {
      "id": "SOL-2024-007",
      "name": "Unbounded Loop Over Storage",
      "description": "Iterating over unbounded collections from storage can exhaust the CPU instruction budget.",
      "severity": "high",
      "category": "resource",
      "pattern": "for\\s+\\w+\\s+in\\s+.*\\.iter\\(\\)|loop\\s*\\{[^}]*storage\\(\\)",
      "recommendation": "Use pagination or set a maximum iteration limit to prevent CPU budget exhaustion.",
      "references": ["https://soroban.stellar.org/docs/fundamentals/fees-and-metering"]
    },
    {
      "id": "SOL-2024-008",
      "name": "Cross-Contract Call Without Error Handling",
      "description": "Invoking another contract without handling potential failures can leave state inconsistent.",
      "severity": "medium",
      "category": "error-handling",
      "pattern": "invoke_contract\\s*[:(]|client\\.\\w+\\(&env",
      "recommendation": "Wrap cross-contract calls in error handling and revert state changes on failure.",
      "references": []
    },
    {
      "id": "SOL-2024-009",
      "name": "Missing Allowance Check",
      "description": "Token spending on behalf of another user without verifying allowance.",
      "severity": "high",
      "category": "access-control",
      "pattern": "fn\\s+transfer_from\\s*\\([^)]*\\)(?![\\s\\S]*?allowance)",
      "recommendation": "Check and deduct allowance before transferring tokens on behalf of another user.",
      "references": []
    },
    {
      "id": "SOL-2024-010",
      "name": "Timestamp Manipulation Risk",
      "description": "Using ledger timestamp for critical logic without safety margins enables manipulation by validators.",
      "severity": "medium",
      "category": "logic",
      "pattern": "ledger\\(\\)\\.timestamp\\(\\)|env\\.ledger\\(\\)\\.timestamp",
      "recommendation": "Avoid relying on precise timestamps for critical decisions. Use block sequence numbers or add safety margins.",
      "references": []
    },
    {
      "id": "SOL-2024-011",
      "name": "Unchecked Return Value from Storage",
      "description": "Using unwrap() on storage get() calls causes panics when keys don't exist.",
      "severity": "medium",
      "category": "error-handling",
      "pattern": "storage\\(\\)\\.[a-z]+\\(\\)\\.get\\([^)]*\\)\\.unwrap\\(\\)",
      "recommendation": "Use unwrap_or_default() or handle the None case explicitly.",
      "references": []
    },
    {
      "id": "SOL-2024-012",
      "name": "Integer Overflow in Token Arithmetic",
      "description": "Using standard arithmetic operators on token amounts without overflow protection.",
      "severity": "high",
      "category": "arithmetic",
      "pattern": "supply\\s*\\+|supply\\s*\\+=|total_supply.*\\+",
      "recommendation": "Use checked_add(), checked_sub(), checked_mul() for all token arithmetic.",
      "references": []
    }
  ]
}
